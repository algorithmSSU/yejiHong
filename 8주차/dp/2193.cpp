#include <cstdio>
#include <iostream>

using namespace std;
long long int dp[91][2];

int main()
{
    int n;
    cin >> n;
    dp[1][1] = 1;
    dp[2][1] = 1;

    for (int i = 3; i <= n;i++){
        for (int j= 0; j < 2;j++){
            if(j==0){
                continue;
            }else if(j==1){
                dp[i][1] = dp[i - 1][1] + dp[i - 2][1];
            };
        };
    };

    cout << dp[n][1] << endl;
};


/*

이친수 조건 
1. 0으로 시작하지 않음
2. 1이 두번 연속으로 나타나지 않음

-> ex) 1, 10, 100, 101, 1000, 1010, 1001 ...

[1] : 0 | 1 -> 0으로 시작하는 숫자는 이친수 조건이 아니므로, 1자리로 나타내는 이친수는 1개 
[2] : 00, 01 | 10, 11 -> 상동 조건 + 1이 연속으로 나타나지 않아야 하므로, 2자리로 나타낼 수 있는 이친수는 1개
[3] : 000, 001, 010, 011 | 100, 101, 110, 111 -> 상동조건 적용 , 3자리로 나타낼 수 있는 이친수는 2개
[4] : 1000, 1010, 1001 -> 3개 / 2/1
[5] : 10000, 10100, 10101, 10010, 10001 -> 5개 / 3/2
[6] : 100000, 100001, 101001, 101000, 101010, 100100, 100111, 100010 -> 8개 / 5/3
[7] : 13개 / 8/5
[8] : 21개

[n-2]+[n-1] = [n] 패턴을 찾았음


패턴 분석
1. n자리 이친수 중 끝나는 숫자가 0이면 n+1자리에서 2개의 이친수가 추가로 생길 수 있고,
                                1이면 n+1자리에서 1개의 이친수가 추가로 생길 수 있다.

즉, n+1자리의 이친수 갯수 = n자리의 이친수 중 (0으로 끝나는 수의 갯수 * 2) + (1로 끝나는 수 갯수)
n+1 = n + n-1


*/